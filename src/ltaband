#!/bin/sh
# Sanjay\
exec wish "$0" "$@"

#
# Gets the total content header and data structure of the xtract data.
#

set phson 1
set ys logscale
set band_file "all.band"
set lta_file ""
set do_band 0
set integ ""
set err_stat 0

if {[info exists env(GDOC)] == 1 } {
	set gdoc $env(GDOC)
} else {
	set err_stat 1
}


# if do_band== 0, it means do xtract, and if do_band=1 means do not xtract, rather use band file.

for { set narg 0 } { $narg < $argc } { incr narg } {
    if { [string compare [lindex $argv $narg] "-l"] == 0 || [string compare [lindex $argv $narg] "-L"] == 0 } {
        incr narg
		set lta_file [lindex $argv $narg]
		set do_band 0
    } elseif { [string compare [lindex $argv $narg] "-b"] == 0 || [string compare [lindex $argv $narg] "-B"] == 0 } {
        incr narg
		set band_file [lindex $argv $narg]
		set do_band 1
    } elseif { [string compare [lindex $argv $narg] "-h"] == 0 || [string compare [lindex $argv $narg] "-H"] == 0 } {
        puts stdout ""
		puts stdout "ltaband -b band_file -l lta_file"
        puts stdout ""
		exit
    } else {
        set option [lindex $argv $narg]
        puts stdout ""
        puts stdout "Unknown option: $option"
		puts stdout "ltaband -b band_file -l lta_file"
        puts stdout ""
		exit
	}
}

set gnucmd "gnuplot -noraise"
set gnuinp [ open |$gnucmd r+ ]
set azelgnu [ open |$gnucmd r+ ]
set sb USB
set oneformat 0
set data_format 0
set res .01

set isrange 0
set antenna(0) C00;
set antenna(1) C01;
set antenna(2) C02; 
set antenna(3) C03;
set antenna(4) C04; 
set antenna(5) C05; 
set antenna(6) C06; 
set antenna(7) C08;
set antenna(8) C09; 
set antenna(9) C10; 
set antenna(10) C11; 
set antenna(11) C12;
set antenna(12) C13; 
set antenna(13) C14; 
set antenna(14) E02; 
set antenna(15) E03;
set antenna(16) E04; 
set antenna(17) E05; 
set antenna(18) E06; 
set antenna(19) S01;
set antenna(20) S02; 
set antenna(21) S03; 
set antenna(22) S04; 
set antenna(23) S06;
set antenna(24) W01; 
set antenna(25) W02; 
set antenna(26) W03; 
set antenna(27) W04;
set antenna(28) W05; 
set antenna(29) W06;
set antenna(30) W06;

puts $gnuinp "reset"
puts $gnuinp "set linesize 4.0"
puts $gnuinp "set rmargin 5"
puts $gnuinp "set lmargin 15"
puts $gnuinp "set logscale y"
puts $gnuinp "set xlabel \"Channel\""
puts $gnuinp "set ylabel \"Power\""
puts $gnuinp "set autoscale x"
set x_title "Channel"

#set print_cmd "lp -dnetp1 -onobanner "
set print_cmd "lpr -Pnpsr"
set op_to 2
set orient landscape
set gscale monochrome
set first_time 1
#set first_ip 1

set xmin 0
set xmax 260
set ymin 1
set ymax 50000
set newyrange 50000

set x1 0
set x2 260
set y1 *
set y2 *

set rewind_size 0
set cur_rec 0
set last_chan -1
set data_size 0
set stopped 1
set scans ""
set ref_ant C00
set pol1 1
set pol2 1
set amp 1
set phs 0
set fmt_both 1
set tcl_precision 6
set self 1
set orient landscape
set gscale monochrome
set key_val 1
set grid 1
set single_ant 0
set gset 0
set yid 0
set axis 0
set gnu_cmd ""
set ant1 ""
set ant2 ""
set ex1 *
set ex2 *

##--- Creates Graphical User Interface ---##

frame .f1 -relief ridge -bd 4

frame .f1.frame1 -relief ridge -bd 2
frame .f1.frame2 -relief ridge -bd 2
frame .f1.frame3 -relief ridge -bd 2

frame .f1.frame1.sub_frame1
frame .f1.frame1.sub_frame2
frame .f1.frame2.sub_frame1
frame .f1.frame2.sub_frame2
frame .f1.frame3.sub_frame1
frame .f1.frame3.sub_frame2

set check_bg #bbbbc2
set i 1
while { $i < 11 } {
    checkbutton .f1.frame1.sub_frame1.s$i -text $antenna([expr $i-1]) -variable smpu($i) -onvalue 1 -offvalue 0\
	    -state disabled -background $check_bg  -activeforeground blue  -activebackground #ddccdd
    checkbutton .f1.frame1.sub_frame2.s$i -text $antenna([expr $i-1]) -variable smpl($i) -onvalue 1 -offvalue 0 \
	    -state disabled  -background $check_bg  -activeforeground blue  -activebackground #ddccdd
    checkbutton .f1.frame2.sub_frame1.s$i -text $antenna([expr $i+9]) -variable smpu([expr $i+10]) -onvalue 1 -offvalue 0\
	    -state disabled  -background $check_bg  -activeforeground blue  -activebackground #ddccdd
    checkbutton .f1.frame2.sub_frame2.s$i -text $antenna([expr $i+9]) -variable smpl([expr $i+10]) -onvalue 1 -offvalue 0\
	    -state disabled  -background $check_bg  -activeforeground blue  -activebackground #ddccdd
    checkbutton .f1.frame3.sub_frame1.s$i -text $antenna([expr $i+19]) -variable smpu([expr $i+20]) -onvalue 1 -offvalue 0\
	    -state disabled  -background $check_bg  -activeforeground blue  -activebackground #ddccdd
    checkbutton .f1.frame3.sub_frame2.s$i -text $antenna([expr $i+19]) -variable smpl([expr $i+20]) -onvalue 1 -offvalue 0\
	    -state disabled  -background $check_bg  -activeforeground blue  -activebackground #ddccdd
    incr i
}

pack .f1.frame1.sub_frame1.s1 .f1.frame1.sub_frame1.s2 .f1.frame1.sub_frame1.s3 .f1.frame1.sub_frame1.s4 \
	.f1.frame1.sub_frame1.s5 .f1.frame1.sub_frame1.s6 .f1.frame1.sub_frame1.s7 \
	.f1.frame1.sub_frame1.s8 .f1.frame1.sub_frame1.s9 .f1.frame1.sub_frame1.s10 -side left -fill both -expand 1

pack .f1.frame1.sub_frame2.s1 .f1.frame1.sub_frame2.s2 .f1.frame1.sub_frame2.s3 .f1.frame1.sub_frame2.s4 \
	.f1.frame1.sub_frame2.s5 .f1.frame1.sub_frame2.s6 .f1.frame1.sub_frame2.s7 \
	.f1.frame1.sub_frame2.s8 .f1.frame1.sub_frame2.s9 .f1.frame1.sub_frame2.s10 -side left -fill both -expand 1

pack .f1.frame1.sub_frame1 .f1.frame1.sub_frame2 -side top -fill both -expand 1
pack .f1.frame1 -fill both -expand 1

pack .f1.frame2.sub_frame1.s1 .f1.frame2.sub_frame1.s2 .f1.frame2.sub_frame1.s3 .f1.frame2.sub_frame1.s4 \
	.f1.frame2.sub_frame1.s5 .f1.frame2.sub_frame1.s6 .f1.frame2.sub_frame1.s7 \
	.f1.frame2.sub_frame1.s8 .f1.frame2.sub_frame1.s9 .f1.frame2.sub_frame1.s10 -side left -fill both -expand 1

pack .f1.frame2.sub_frame2.s1 .f1.frame2.sub_frame2.s2 .f1.frame2.sub_frame2.s3 .f1.frame2.sub_frame2.s4 \
	.f1.frame2.sub_frame2.s5 .f1.frame2.sub_frame2.s6 .f1.frame2.sub_frame2.s7 \
	.f1.frame2.sub_frame2.s8 .f1.frame2.sub_frame2.s9 .f1.frame2.sub_frame2.s10 -side left -fill both -expand 1

pack .f1.frame2.sub_frame1 .f1.frame2.sub_frame2 -side top -fill both  -expand 1
pack .f1.frame2 -fill both -expand 1

pack .f1.frame3.sub_frame1.s1 .f1.frame3.sub_frame1.s2 .f1.frame3.sub_frame1.s3 .f1.frame3.sub_frame1.s4 \
	.f1.frame3.sub_frame1.s5 .f1.frame3.sub_frame1.s6 .f1.frame3.sub_frame1.s7 \
	.f1.frame3.sub_frame1.s8 .f1.frame3.sub_frame1.s9 .f1.frame3.sub_frame1.s10 -side left -fill both -expand 1

pack .f1.frame3.sub_frame2.s1 .f1.frame3.sub_frame2.s2 .f1.frame3.sub_frame2.s3 .f1.frame3.sub_frame2.s4 \
	.f1.frame3.sub_frame2.s5 .f1.frame3.sub_frame2.s6 .f1.frame3.sub_frame2.s7 \
	.f1.frame3.sub_frame2.s8 .f1.frame3.sub_frame2.s9 .f1.frame3.sub_frame2.s10 -side left -fill both -expand 1

pack .f1.frame3.sub_frame1 .f1.frame3.sub_frame2 -side top -fill both  -expand 1
pack .f1.frame3 -fill both -expand 1

##--- Create Text-Entry for Gnu Cpmmand and command buttons ---##

frame .f2 -relief ridge -bd 4

frame .f2.key -relief raised -bd 2
radiobutton .f2.key.r1 -text "Key On " -variable key_val -value 1 -bg "#aabbb0" \
	-activeforeground blue -cursor hand2 
radiobutton .f2.key.r2 -text "Key Off" -variable key_val -value 2 -bg "#aabbb0" \
	-activeforeground blue -cursor hand2

pack .f2.key.r1 .f2.key.r2 -side left -fill both -expand 1

frame .f2.grid -relief raised -bd 2
radiobutton .f2.grid.r1 -text "Grid Off" -variable grid -value 0 -bg "#aab0bb" \
	-activeforeground blue -cursor hand2
radiobutton .f2.grid.r2 -text "Grid On" -variable grid -value 1 -bg "#aab0bb" \
	-activeforeground blue -cursor hand2

pack .f2.grid.r1 .f2.grid.r2 -side left -fill both -expand 1

# azel is the choice whether az or el to plot in gnuplot.
frame .f2.azel -relief raised -bd 2
radiobutton .f2.azel.az -text "Az" -variable axis -value 0 -bg "#bbaabb" -activeforeground blue -cursor hand2
radiobutton .f2.azel.el -text "El" -variable axis -value 1 -bg "#bbaabb" -activeforeground blue -cursor hand2
radiobutton .f2.azel.all -text "All" -variable axis -value 2 -bg "#bbaabb" -activeforeground blue -cursor hand2
pack .f2.azel.az .f2.azel.el .f2.azel.all -side left -fill both -expand 1

set format 0

set text1 "Amp"
set text2 "Phs"
set text3 "All"

frame .f2.format -relief raised -bd 2
radiobutton .f2.format.rad1 -text $text1 -variable format -value 1 -bg "#bbaabb" \
	-activeforeground blue -cursor hand2
radiobutton .f2.format.rad2 -text $text2 -variable format -value 2 -bg "#bbaabb" \
	-activeforeground blue -cursor hand2
radiobutton .f2.format.rad3 -text $text3 -variable format -value 0 -bg "#bbaabb" \
	-activeforeground blue -cursor hand2

if { $fmt_both == 0 } {
    set format 1
    .f2.format.rad2 configure -state disabled
    .f2.format.rad3 configure -state disabled
}

pack .f2.format.rad1 .f2.format.rad2 .f2.format.rad3 -side left -fill both -expand 1

frame .f2.log -relief raised -bd 2
radiobutton .f2.log.r1 -text "Log" -variable ys -value logscale -bg "#aabbb0" \
	-activeforeground blue -cursor hand2 
radiobutton .f2.log.r2 -text "Lin" -variable ys -value nologscale -bg "#aabbb0" \
	-activeforeground blue -cursor hand2
pack .f2.log.r1 .f2.log.r2 -side left -fill both -expand 1

pack .f2.key .f2.azel .f2.grid .f2.format .f2.log -side left -fill both -expand 1

frame .f4 -relief ridge -bd 4
frame .f4.cont -relief raised -bd 2
scale .f4.cont.sc1 -from 100 -to 16000 -variable speed -length 200 -orient horizontal \
	-label "Playback interval - ms" -showvalue true -bg #bbaaac -digits 1 -resolution 200
scale .f4.cont.sc2 -from 0 -to 2000 -variable position -length 200 -orient horizontal \
	-label "Current Position - Rec. #" -showvalue true -bg #aabbac -digits 1 -resolution 1 -state disabled\
	-command { relocate }

#########################################################################
button .f4.cont.start -text "  PLAY   |> "  -bd 2  -activeforeground blue -cursor hand2 -state disabled -command {
	if $stopped {
		set active [ up_count ]
		if { $active == 0 } {
			set msg "No antennas selected!"
			tk_messageBox  -default ok -message $msg -parent . -title "Error" -type ok
			.f4.cont.start configure -text "  PLAY   |> "
			.f3.print configure -state normal
			.f3.file configure -state normal
			set stopped 1
			return 
		}
		.f3.print configure -state disabled
		.f3.file configure -state disabled
		.f3.stop configure -state normal
		.f3.range configure -state normal
		.f4.cont.sc2 configure -state normal
		.f4.cont.start configure -text "  PAUSE || "
		.f3.stop conf -state normal
		set stopped 0
		plot_cont
	} else {
		.f4.cont.start configure -text "  PLAY   |> "
		.f3.print configure -state normal
		.f3.file configure -state normal
		set stopped 1
	}
}
#########################################################################
pack .f4.cont.sc1 .f4.cont.sc2 .f4.cont.start -side left -fill both -expand 1
pack .f4.cont -fill both -expand 1

frame .f3 -relief raised -bd 4

button .f3.print -text "Print" -command {print_post} -bd 2 -state disabled \
	-activeforeground blue -cursor hand2

#########################################################################
button .f3.stop -text "STOP" -bd 2 -cursor hand2 -activeforeground blue -state disabled\
 -command { set stopped 1
		set cur_rec 0;
		set position 0;
		seek $dat_file $rewind_size start;
		plot_one
		.f4.cont.start configure -text "  PLAY   |> "
		.f3.print configure -state normal
		.f3.file configure -state normal
		.f3.stop conf -state disabled
	}
#########################################################################
#########################################################################

button .f3.range -bd 2 -text "X-Y Range" -activeforeground blue -cursor hand2 -command set_range -state disabled
button .f3.azel -bd 2 -text "AZ-EL" -activeforeground blue -cursor hand2 -command { plot_azel} -state disabled
button .f3.clear -bd 2 -text "Clear" -activeforeground blue -cursor hand2 -command {
    set id 1
    while { $id < 31 } {
		set smpu($id) 0
		set smpl($id) 0
		incr id
    }
	.f4.cont.start configure -text "  PLAY   |> "
	.f3.print configure -state normal
	.f3.file configure -state normal
	set stopped 1
}

# In plotgnu, 0 is for the terminal which is x11 here, for the postscript it is 1 which 
# is invoked through the proc invoked by button "Print"
button .f3.file -bd 2 -text "INPUT" -command { .f3.file config -state disabled; get_file }  -activeforeground blue -cursor hand2

button .f3.help -text Help -command { help } -bd 2 -activeforeground blue -cursor hand2
button .f3.quit -text " Quit " -bd 2 -command {
    #	unset data ant_list col_list fmt_list lta ncols chan1 chan2 chaninc x_title
    puts $gnuinp "quit"
    destroy .
} -activeforeground blue -cursor hand2

pack .f3.clear .f3.azel .f3.range .f3.stop .f3.file .f3.print .f3.help .f3.quit -side left -expand 1 -fill x

##--- Packing all widgets together to form whole application ---##
pack .f1 .f2 .f4 .f3 -side top -fill both

wm title . "LTA Bands"

wm protocol . WM_DELETE_WINDOW { wm_error }

bind . <q> {destroy .}

###---- Finished major GUI Widget's here-----------------###

proc go {} {
	global band_file do_band 

	if { $do_band == 0 } {
		do_xtract
	} else {
	    if { [file exists $band_file ] != 1 } {
			set msg "$band_file: file does not exist,\n Try Again!"
			tk_messageBox  -default ok -message $msg -parent . -title "Error" -type ok
			return
		}
	}

	read_data
   	destroy .fi
   	.f3.file config -state normal
}

proc get_file {} {
    global self ref_ant argc argv sb band_file do_band chan1 chan2 chan3 integ

    #--- toplevel name .fi for "file input"
    if [winfo exists .fi ] { bell;bell;return }
    
    toplevel .fi
    
    frame .fi.f1 -relief raise -bd 5
    frame .fi.f1.sf1 -relief ridge -bd 1
    frame .fi.f1.sf2 -relief ridge -bd 1
    frame .fi.f1.sf3 -relief ridge -bd 1
    frame .fi.f1.sf4 -relief ridge -bd 1
    frame .fi.f1.sf5 -relief ridge -bd 1
    frame .fi.f1.sf6 -relief ridge -bd 1
    frame .fi.f1.sf7 -relief ridge -bd 1
    frame .fi.f1.sf8 -relief ridge -bd 1
    frame .fi.f1.sf9 -relief ridge -bd 1
    
    label .fi.f1.sf1.l1 -text "Bandshapes For :"
    radiobutton .fi.f1.sf1.r1 -text "Self Power" -variable self -value 1\
	    -activeforeground blue -cursor hand2
    radiobutton .fi.f1.sf1.r2 -text "Cross Amp/Phs" -variable self -value 2\
	    -activeforeground blue -cursor hand2
    
    pack .fi.f1.sf1.l1 .fi.f1.sf1.r1 .fi.f1.sf1.r2 -side left -fill both -expand 1
    
    label .fi.f1.sf2.l2 -text "Ref. Antenna:"
    entry .fi.f1.sf2.e1 -textvariable ref_ant -state disabled -bg #ffdddd -width 5
    label .fi.f1.sf2.l3 -text "Scans:"
    entry .fi.f1.sf2.e2 -textvariable scans -bg #ffdddd
    
    pack .fi.f1.sf2.l2 .fi.f1.sf2.e1 .fi.f1.sf2.l3 .fi.f1.sf2.e2 -side left -fill both -expand 1 -pady 3
    
    label .fi.f1.sf3.l2 -text "Chan. Range (Start | Stop | Step):"
    entry .fi.f1.sf3.e1 -textvariable chan1 -bg #ffdddd -width 5
    entry .fi.f1.sf3.e2 -textvariable chan2 -bg #ffdddd -width 5
    entry .fi.f1.sf3.e3 -textvariable chan3 -bg #ffdddd -width 5
    
    pack .fi.f1.sf3.l2 .fi.f1.sf3.e1 .fi.f1.sf3.e2 .fi.f1.sf3.e3 -side left -fill both -expand 1 -pady 3
    
    label .fi.f1.sf7.l3 -text "BAND File:"
    entry .fi.f1.sf7.e0 -textvariable band_file -bg #ffdddd -width 35
    pack .fi.f1.sf7.l3 .fi.f1.sf7.e0 -side left -fill both -expand 1 -pady 3
    
    label .fi.f1.sf9.l2 -text "Integration(xtract format):"
    entry .fi.f1.sf9.e1 -textvariable integ -bg #ffdddd -width 10
    pack .fi.f1.sf9.l2 .fi.f1.sf9.e1 -side left -fill both -expand 1 -pady 3
    
    label .fi.f1.sf4.l2 -text "   LTA File:"
    entry .fi.f1.sf4.e1 -textvariable lta_file -bg #ffdddd -width 35
    pack .fi.f1.sf4.l2 .fi.f1.sf4.e1 -side left -fill both -expand 1 -pady 3
    
    label .fi.f1.sf8.l1 -text "MODE :"
    radiobutton .fi.f1.sf8.c1 -text "Do Xtract" -variable do_band -activeforeground blue -cursor hand2 -value 0
    radiobutton .fi.f1.sf8.c2 -text "Use BAND FILE" -variable do_band -activeforeground blue -cursor hand2 -value 1
    pack .fi.f1.sf8.l1 .fi.f1.sf8.c1 .fi.f1.sf8.c2 -side left -fill both -expand 1

    label .fi.f1.sf5.l1 -text "Parameters :"
    checkbutton .fi.f1.sf5.c1 -text "Amp" -variable amp -activeforeground blue -cursor hand2
    checkbutton .fi.f1.sf5.c2 -text "Phs" -variable phs -activeforeground blue -cursor hand2 -state disabled
    
    pack .fi.f1.sf5.l1 .fi.f1.sf5.c1 .fi.f1.sf5.c2 -side left -fill both -expand 1

    label .fi.f1.sf6.l1 -text "Polarizaion :"
    checkbutton .fi.f1.sf6.c1 -text "130 MHz" -variable pol1 -activeforeground blue -cursor hand2
    checkbutton .fi.f1.sf6.c2 -text "175 MHz" -variable pol2 -activeforeground blue -cursor hand2
    
    pack .fi.f1.sf6.l1 .fi.f1.sf6.c1 .fi.f1.sf6.c2 -side left -fill both -expand 1
    
    pack .fi.f1.sf8 .fi.f1.sf4 .fi.f1.sf7 .fi.f1.sf1 .fi.f1.sf2 .fi.f1.sf6 .fi.f1.sf3 .fi.f1.sf9 .fi.f1.sf5 -side top -fill both -expand 1 -ipady 1
    
    frame .fi.f2 -relief raise -bd 5
    button .fi.f2.b1 -text "GO" -activeforeground blue -cursor hand2 -command { go }
    button .fi.f2.b2 -text "Help" -command { help } -activeforeground blue -cursor hand2
    button .fi.f2.b3 -text "Cancel" -command {.f3.file config -state normal; destroy .fi; return} -activeforeground blue -cursor hand2
    
    pack .fi.f2.b1 .fi.f2.b2 .fi.f2.b3 -side left -padx 7 -ipadx 5 -fill both -expand 1
    pack .fi.f1 .fi.f2 -side top -fill both -expand 1
    
    wm title .fi "Input Parameters"
    
    bind .fi.f1.sf1.r2 <1> {
		if { $self != 0 } {
			puts $gnuinp "set nologscale y"
			.fi.f1.sf2.e1 configure -state normal
			.fi.f1.sf5.c2 configure -state normal
		}
    }
    
    bind .fi.f1.sf1.r1 <1> {
		puts $gnuinp "set logscale y"
		.fi.f1.sf2.e1 configure -state disabled
		set phs 0
		set amp 1
		.fi.f1.sf5.c2 configure -state disabled
    }
}

proc plot_azel {} {
	global azelgnu axis sb

	if { $axis == 0 } { 
		set azel_cmd "plot \"azel.dat\" u 1:3  title \"AZIM\" w l"
	} elseif { $axis == 1 } {
		set azel_cmd "plot \"azel.dat\" u 1:2 title \"ELEV\" w l"
	} elseif { $axis == 2 } {
		set azel_cmd "plot \"azel.dat\" u 1:3 title \"AZIM\" w l\, \"\" u 1:2 title \"ELEV\" w l"
	}
	puts $azelgnu "set xla \"IST(Hrs.)\""
	puts $azelgnu "set yla \"Az-El angle(Deg.)\""
	puts $azelgnu $azel_cmd
	flush $azelgnu
}

proc do_xtract {} {
    global lta_file scans ref_ant self amp phs chan1 chan2 chan3
	global pol1 pol2 argc dat_file sb band_file integ
    
    if { [string compare $lta_file "" ] == 0 } {
		set msg "Lta file needed"
		tk_messageBox  -default ok -message $msg -parent .fi -title "Error" -type ok
		return
    }
    if { [file exists $lta_file ] != 1 } {
		set msg "$lta_file: file does not exist"
		tk_messageBox  -default ok -message $msg -parent .fi -title "Error" -type ok
		return
    } else {
		set chanfile [open $lta_file r]
		while {1} {
		    gets $chanfile line
		    if {[string compare [lindex $line 0] "CHAN_NUM="] == 0 } {
				set chan_range [lindex $line 1]
				set ch1 [ lindex [split $chan_range ":" ] 0 ]
				set ch2 [ lindex [split $chan_range ":" ] 1 ]
				set ch3 [ lindex [split $chan_range ":" ] 2 ]
#				puts stdout "CHAN=$chan_range"
#				puts stdout "CH1:$ch1 CH2=$ch2 CH3=$ch3"
				break
		    }
		}
		close $chanfile
    }

    if { [string compare $chan1 "" ] == 0 || $chan1 < 0 || $chan1 > 128 } {
		set chan1 $ch1
    }
    if { [string compare $chan2 "" ] == 0 || $chan2 < 0 || $chan2 > 128 } {
		set chan2 $ch2
    }
    if { [string compare $chan3 "" ] == 0 } {
		set chan3 $ch3
    }
    if { $chan3 < 0 || $chan3 > 128 } {
		set msg "$chan3: Channel step not proper, see help."
		tk_messageBox  -default ok -message $msg -parent .fi -title "Error" -type ok
		return
    }
    set chan_diff [expr $chan2 - $chan1]
    if { $chan3 > $chan_diff } {
		set chan3 $chan_diff
		set msg "Channel step not proper, forcing to $chan3."
		tk_messageBox  -default ok -message $msg -parent .fi -title "Error" -type ok
    }
    
	if { $self == 2 } {
		if { [string compare $ref_ant "" ] == 0 } {
			set msg "Need Refrence antenna"
			tk_messageBox  -default ok -message $msg -parent .fi -title "Error" -type ok
			return
		}
	}
    ###------ Writing xtract.def ------####
    set def [open "xtract.def" w]
    puts $def "in         = $lta_file"
    puts $def "out        = $band_file"
    puts $def "scans      = $scans"
    puts $def "object     = ."
    puts $def "timestamps = "

	if { $pol1 == 1 && $pol2 == 1 || $pol1 == 0 && $pol2 == 0 } {
		if { $self == 1 } {
			puts $def "baselines  = A.+"
		} else {
			puts $def "baselines  = $ref_ant"
		}
	} elseif { $pol1 == 1 } {
		if { $self == 1 } {
			puts $def "baselines  = A.+-130"
		} else {
			puts $def "baselines  = $ref_ant-$sb-130"
		}
	} else {
		if { $self == 1 } {
			puts $def "baselines  = A.+-175"
		} else {
			puts $def "baselines  = $ref_ant-$sb-175"
		}
	}

    puts $def "channels   = $chan1,$chan2,$chan3"
    puts $def "antennas   = "
    puts $def "integtime  = $integ"
    puts $def "normalize  = 1"
    if { $self == 1 || $amp == 1 && $phs == 0 } {
		puts $def "fmt        = chan{el;az;ist%10.5f;cno;base{a%13.4f};\\\\n}"
    } elseif { $amp == 1 && $phs == 1 } {
		puts $def "fmt        = chan{el;az;ist%10.5f;cno;base{a%13.4f;p%11.4f};\\\\n}"
    } else {
		puts $def "fmt        = chan{el;az;ist%10.5f;cno;base{p%11.4f};\\\\n}"
    }
    close $def

   	catch [exec echo go | xtract eat=0]
	destroy .fi
}

proc read_data {} {
  global lta nrows ncols chan1 chan2 chaninc antenna speed format dat_file band_file
	global title data_size scan_size rec_size tot_bands tot_chan fmt n_scan sb ref_ant
	global title_log ft1 ft2 isref col_list fmt_list lta_file position cur_rec smpu smpl
	global oneformat data_format y1 y2 x1 x2 ymin ymax xmin xmax band_file lta_file
	global self gnuinp phson
    
	set dat_file -1
	set data_size 0
    set dat_file [open $band_file r]
	seek $dat_file 0 start
	set position 0
	set cur_rec 0
    while { 1 } {
		gets $dat_file line
		incr data_size [string length $line]
		incr data_size +1
		set caption [lindex $line 0]
		set cap_data [lindex $line 1]
		
		if { [string compare $caption "#LTAT" ] == 0 } {
		    set lta $cap_data
			set up_limit [expr 1000 * $lta]
			.f4.cont.sc1 configure -to $up_limit
		} elseif { [string compare $caption "#NROWS" ] == 0 } {
		    set nrows $cap_data
		} elseif { [string compare $caption "#NCOLS" ] == 0  } {
		    set ncols $cap_data
		} elseif { [string compare $caption "#CHAN1" ] == 0  } {
		    set chan1 $cap_data
		} elseif { [string compare $caption "#CHAN2" ] == 0  } {
		    set chan2 $cap_data
		} elseif { [string compare $caption "#CHANINC" ] == 0  } {
		    set chaninc $cap_data
		} elseif { [string compare $caption "#LABEL04" ] == 0  } {
			set sb [string range $cap_data 4 6]
		    break
		}
    }
    
	set junk1 [expr $chan2 - $chan1]
	set junk2 [expr $junk1/$chaninc]
	set tot_chan [expr int($junk2) + 1]
	unset junk1 junk2
	
#    set ref_ant junk
    set ref1_cnt 0
    set ref2_cnt 0
    
    #
    # Gets the real data description of each column.
    #
    
    set active 0
    set fmt_both 1
    set id 1
    

    set col_list ""
    set fmt_list ""
    set ant_list ""
    
    set isref 1
    while { 1 } {
		set caption [lindex $line 0]
		if { [string compare $caption "#End" ] == 0 } {
		    break
		}
	
		# ant_cap is the antenna combination caption like C09-$sb-130:E03-$sb-130
		set ant_cap [lindex $line 1 ]
		set ant1 [string range $ant_cap 0 2]
		set ant2 [string range $ant_cap 12 14]
		set pol [string range $ant_cap 8 10]
		if { $id == 1 } {
		    set ref1 $ant1
		    set ref2 $ant2
		}
		
		if { $ant2 == "" } {
		    set single_ant 1
		}
		if { $isref == 1 } {
		    if { [string compare $ant1 $ant2] == 0  } {
			set isref 0
			set ref_ant $ant1
		    } else {
			if { [string compare $ant1 $ref1 ] == 0 || [string compare $ant2 $ref1 ] == 0 } {
			    incr ref1_cnt
			} else { incr ref2_cnt }
		    }
		}
		
		lappend col_list [lindex $line 1]
		lappend fmt_list [lindex $line 2]
		
		if { [lsearch $ant_list $ant1-$pol ] == -1 } {
		    lappend ant_list $ant1-$pol
		}
		
		if { [lsearch $ant_list $ant2-$pol ] == -1 } {
		    lappend ant_list $ant2-$pol
		}
		incr id
		gets $dat_file line
		incr data_size [string length $line]
		incr data_size +1
    }

	set ft1 [lindex $fmt_list 0]
	set ft2 [lindex $fmt_list 1]

	if { $ft1 == $ft2 } { set fmt_both 0 }

    if { $isref == 1 } {
		set self 2
		if { $ref1_cnt > $ref2_cnt } {
		    set ref_ant $ref1
		} else { set ref_ant $ref2 }
	
		set repl_index [lsearch -exact $ant_list $ref_ant-130]
		set ant1_list [lreplace $ant_list $repl_index $repl_index]
		set ant_list $ant1_list
		unset ant1_list
		
		set repl_index [lsearch -exact $ant_list $ref_ant-175]
		set ant1_list [lreplace $ant_list $repl_index $repl_index]
		set ant_list $ant1_list
		unset ant1_list

		puts $gnuinp "set nologscale y"
#   this need to be checked.
#		.fi.f1.sf2.e1 configure -state normal
#		.fi.f1.sf5.c2 configure -state normal
   	 } else {
		set self 1
		puts $gnuinp "set logscale y"
#		.fi.f1.sf2.e1 configure -state disabled
		set phs 0
		set amp 1
#		.fi.f1.sf5.c2 configure -state disabled
	}
    
    #
    # And now the left over is the actual data.
    #
    
	set temp1 [lindex $fmt_list 0]
	set temp2 [lindex $fmt_list 1]
    
    if { [string compare $temp1 $temp2 ] == 0 } {
		set fmt_both 0 
		set format 1
		.f2.format.rad2 configure -state disabled
		.f2.format.rad3 configure -state disabled
		set oneformat 1
	}
    
	if { [string compare $temp1 "a" ] == 0 } {
		.f2.format.rad1 configure -text Amp
		set data_format 1
	} elseif { [string compare $temp1 "p" ] == 0 } {
		.f2.format.rad1 configure -text Phs
		set data_format 2
	} elseif { [string compare $temp1 "re" ] == 0 } {
		.f2.format.rad1 configure -text Real
	} elseif { [string compare $temp1 "im" ] == 0 } {
		.f2.format.rad1 configure -text Imaginary
	}

	if { [string compare $temp2 "a" ] == 0 } {
		.f2.format.rad2 configure -text Amp
		set data_format 1
	} elseif { [string compare $temp2 "p" ] == 0 } {
		.f2.format.rad2 configure -text Phs
		set data_format 2
	} elseif { [string compare $temp2 "re" ] == 0 } {
		.f2.format.rad2 configure -text "Real "
	} elseif { [string compare $temp2 "im" ] == 0 } {
		.f2.format.rad2 configure -text  Imagi
	}

	unset temp1 temp2

#############  this has been introduced here for test ##################
	if { $isref == 0 } {
		set y1 10
		set y2 5000
		set ymin 1
		set ymax 50000
		set res 1
	} elseif { $oneformat == 1 } {
		if { $data_format == 1 } {
			set y1 0.001
			set y2 0.25
			set ymin 0.0
			set ymax 1.00
			set res .005
		} elseif { $data_format == 2 } {
			set y1 -200
			set y2  200
			set ymin -200
			set ymax 200
			set res 1
		}
	} elseif { $oneformat == 0 } {
		if { $format == 1 } {
			set y1 0.001
			set y2 0.25
			set ymin 0.0
			set ymax 1.00
			set res .005
		} elseif { $format == 2 || $format == 0} {
			set y1 -200
			set y2  200
			set ymin -200
			set ymax 200
			set res 1
		}
	}

#############  this has been introduced here for test ##################

	set rewind_size $data_size
    set n_rec 0
	set n_scan 0

## To be changed here ##
    set azelfd [open "azel.dat" w]
    while { 1 } {
		gets $dat_file line
		if { [string compare $line  "" ] == 0 } {
			close $azelfd
			break
		} elseif { [string compare [string range $line 0 0 ]  "#" ] != 0 } {
			set cur_chan [lindex $line 3]
			if { $cur_chan == $chan1 } {
				set el [lindex $line 0]
				set az [lindex $line 1]
				set ist [lindex $line 2]
				puts $azelfd "$ist $el $az"
				set rec_size($n_rec) $data_size
				incr n_rec
			}
			incr data_size [string length $line]
			incr data_size +1
		} elseif { [string compare [string range $line 0 3 ] "#OBJ" ] == 0 } {
			set title1 "$lta_file "
			lappend title1 [lindex $line 1]
#			lappend title1 [lindex $line 8]
			lappend title1 [lindex $line 9]
			lappend title1 [lindex $line 10]
			lappend title1 [lindex $line 11]
			lappend title1 [lindex $line 13]
			set title_log($n_scan) $title1
			incr data_size [string length $line]
			incr data_size +1
			set object($n_scan) [lindex $line 1]
			set scan_size($n_scan) $data_size
			incr n_scan
		}
	}

    set id 1
    while { $id < 31 } {
		set smpu($id) 0
		set smpl($id) 0
		incr id
    }

    set id 1
    while { $id < 11 } {
		.f1.frame1.sub_frame1.s$id configure -state disabled
		.f1.frame1.sub_frame2.s$id configure -state disabled
		.f1.frame2.sub_frame1.s$id configure -state disabled
		.f1.frame2.sub_frame2.s$id configure -state disabled
		.f1.frame3.sub_frame1.s$id configure -state disabled
		.f1.frame3.sub_frame2.s$id configure -state disabled
		incr id
	}

	set tot_bands [expr $n_rec - 1 ]
	.f4.cont.sc2 configure -to $tot_bands
    
### --- NEED TO BE CHECKED THE CORRECT SIZE OF EACH LINE ----###
	seek $dat_file $rewind_size start
#	seek $dat_file 0 start

    set i 1
    while { $i < 11 } {
	if { [lsearch $ant_list $antenna([expr $i-1])-130] != -1 } {
	    .f1.frame1.sub_frame1.s$i configure -state normal
	}
	if { [lsearch $ant_list $antenna([expr $i-1])-175] != -1 } {
	    .f1.frame1.sub_frame2.s$i configure -state normal
	}
	
	if { [lsearch $ant_list $antenna([expr $i+9])-130] != -1 } {
	    .f1.frame2.sub_frame1.s$i configure -state normal
	}
	if { [lsearch $ant_list $antenna([expr $i+9])-175] != -1 } {
	    .f1.frame2.sub_frame2.s$i configure -state normal
	}
	
	if { [lsearch $ant_list $antenna([expr $i+19])-130] != -1 } {
	    .f1.frame3.sub_frame1.s$i configure -state normal
	}
	if { [lsearch $ant_list $antenna([expr $i+19])-175] != -1 } {
	    .f1.frame3.sub_frame2.s$i configure -state normal
	}
	incr i
    }
	.f4.cont.start configure -state normal
	.f3.azel configure -state normal
}

proc plot_cont {} {
	global stopped speed dat_file cur_rec sb

	if $stopped return 

	if { ![eof $dat_file]} {
		plot_one
	} else {
		show_eof
		return
	}
	after $speed plot_cont
}

proc plot_one {} {
	global dat_file gnuinp cur_rec position chan1 tot_chan title1
	global smpu smpl plot_cmd first_plot lta_file title2 sb

	set position $cur_rec
	set outfile [ open one.band w]
	set id 0
	while { $id < $tot_chan } {
		gets $dat_file line
		if { [string compare [string range $line 0 3 ] "#OBJ" ] == 0 } {
			set title1 "$lta_file "
			lappend title1 [lindex $line 1]
#			lappend title1 [lindex $line 8]
			lappend title1 [lindex $line 9]
			lappend title1 [lindex $line 10]
			lappend title1 [lindex $line 11]
			lappend title1 [lindex $line 13]
		} elseif { [string compare [string range $line 0 0] "#" ] != 0 } {
			set cur_chan [lindex $line 3]
			if { $cur_chan == $chan1 } {
				set rec_el [expr double([lindex $line 0])]
				set rec_az [expr double([lindex $line 1])]
				set rec_tim [lindex $line 2]
				set hr [expr int($rec_tim)]
				set rem [expr $rec_tim - $hr ]
				set true_min [expr $rem*60.0 ]
				set min [expr int($true_min)]
				set rem [expr $true_min - $min ]
				set sec [expr round($rem*60.0) ]
				if { [string length $hr ] == 1 } { set hr "0$hr" }
				if { [string length $min ] == 1 } { set min "0$min" }
				if { [string length $sec ] == 1 } { set sec "0$sec" }
				set title2 " EL = $rec_el AZ = $rec_az Time = $hr:$min:$sec"
			}
			puts $outfile $line
			incr id
		} elseif { [string compare $line "" ] == 0 } {
			show_eof
			close $outfile
			return
		} 
	}
	close $outfile

	# Makes active numer of plots double if format is selected Both.

	replot 0
	incr cur_rec
}

proc show_eof {} {
	global stopped dat_file cur_rec position stopped sb band_file

#	set msg "Reached to the EOF"
#	tk_messageBox  -default ok -message $msg -parent . -title "EOF REACHED" -type ok
	set stopped 1
	.f4.cont.start configure -text "  PLAY   |> "
	.f3.file configure -state normal
	close $dat_file
#	set dat_file [open all.band r]
	set dat_file [open $band_file r]
#	seek $dat_file 0 start
	set cur_rec 0
	set position 0
	.f4.cont.start configure -text "  PLAY   |> "
	.f3.print configure -state normal
	.f3.file configure -state normal
	set stopped 1
}

proc relocate { location } {
	global cur_rec position rewind_size rec_size dat_file first_time
	global gnuinp title_log scan_size n_scan rec_size title1 sb

	set cur_rec $position
	if { $first_time == 1 } {
		set first_time 0
		return 
	} else {
		if { $position == 0 } {
			seek $dat_file $rewind_size start
		} else { 
#			seek $dat_file 0 start
			seek $dat_file $rec_size($cur_rec) start 
			puts stdout "Current record = $cur_rec"
		}
		set id 0
		while { $id < $n_scan } {
			if { $scan_size($id) >=  $rec_size($cur_rec) } {
				set title1 $title_log($id)
				break
			}
			incr id
		}
		plot_one
	}
}

proc up_count {} {
    global smpu smpl sb

    set active_but 0
    set id 1
    while { $id < 31 } {
        if { $smpu($id) == 1 } {
            incr active_but
        }
        if { $smpl($id) == 1 } {
            incr active_but
        }
        incr id
    }
    return $active_but
}

proc get_cmd { chan id ft} {
	global isref col_list cmd antenna ref_ant col_list fmt_list first_plot plot_cmd sb

	if { $isref == 0 } {
		set plot_ant $antenna([expr $id - 1])-$sb-$chan:$antenna([expr $id - 1])-$sb-$chan
	} elseif { $isref == 1 } {
		set plot_ant $ref_ant-$sb-$chan:$antenna([expr $id - 1])-$sb-$chan
	}

    set ant_num [lsearch -exact $col_list $plot_ant ]

    if { $ant_num == -1 }  {
        if { $isref == 0 } {
            set plot_ant $antenna([expr $id - 1])-$sb-$chan:$antenna([expr $id - 1])-$sb-$chan
        } else {
            set plot_ant $antenna([expr $id - 1])-$sb-$chan:$ref_ant-$sb-$chan
        }
        set ant_num [ lsearch -exact $col_list $plot_ant ]
    }

    # The following condition is true if the columns in data are like [ ref a p a p a p]
    set format_sel [lsearch -exact $fmt_list $ft]
    if { $format_sel == 1 } { incr ant_num }
	###--- ant_num is increased by 2 bcoz, two columns already exits before real antennas data
	###--- starts, first is IST second is Chan # ----#
	incr ant_num 5

    if { $isref == 0 } {
		if { [string compare $ft "a" ] == 0 } {
            set plot_title "$antenna([expr $id - 1])-$chan Amp" 
		} else {
            set plot_title "$antenna([expr $id - 1])-$chan Phs" 
		}
	} elseif { $isref == 1 } {
		if { [string compare $ft "a" ] == 0 } {
			set plot_title "$antenna([expr $id - 1])-$chan:$ref_ant Amp"
		} else {
			set plot_title "$antenna([expr $id - 1])-$chan:$ref_ant Phs"
		}
	}
	if { $first_plot == 1 } { append plot_cmd "\, \"\" " }
	set first_plot 1
	append plot_cmd "u 4:$ant_num title \"$plot_title\" w l"
}

proc help {} {
	global err_stat gdoc

	if { $err_stat == 1 } { 
		set msg "ENVIRONMENT variable GDOC not existing"
		tk_messageBox  -default ok -message $msg -parent . -title "Error" -type ok
		return
	}

  if [winfo exists .h ] { return }

	toplevel .h
	set font {Helvetica 11}
	button .h.quit -text "Quit" -command {destroy .h}
	pack .h.quit -side top -fill x
	text .h.text -relief sunk -bd 4 -bg gray80 -fg gray10 -yscrollcommand ".h.scroll set "  -font $font
	scrollbar .h.scroll -command ".h.text yview"

	pack .h.scroll -side right -fill y
	pack .h.text -side left -fill both -expand 1
	loadFile "$gdoc/ltaband.help"
	wm geometry .h 675x400
	wm title .h "Help - LTABAND"
}

proc loadFile file {
	.h.text delete 1.0 end
	set f [open $file r]
	while {![eof $f]} {
	.h.text insert end [read $f 1]
	}
	close $f
}

proc set_range {} {
    global y1 y2 x1 x2 xmin xmax ymin ymax sb isref format isrange
	global oneformat data_format

	set isrange 1

	if { $isref == 0 } {
		set y1 10
		set y2 5000
		set ymin 1
		set ymax 50000
		set res 1
	} elseif { $oneformat == 1 } {
		if { $data_format == 1 } {
			set y1 0.0
			set y2 0.25
			set ymin -0.2
			set ymax 1.00
			set res .005
		} elseif { $data_format == 2 } {
			set y1 -200
			set y2  200
			set ymin -200
			set ymax 200
			set res 1
		}
	} elseif { $oneformat == 0 } {
		if { $format == 1 } {
			set y1 0.0
			set y2 0.25
			set ymin -0.2
			set ymax 1.00
			set res .005
		} elseif { $format == 2 || $format == 0} {
			set y1 -200
			set y2  200
			set ymin -200
			set ymax 200
			set res 1
		}
	}

    if [winfo exists .x ] {
    	.x.f1.sf1.sc1 config -from $xmin -to $xmax
    	.x.f1.sf1.sc2 config -from $xmin -to $xmax
    	.x.f1.sf4.sc1 config -from $ymin -to $ymax -resolution $res
	    .x.f1.sf4.sc2 config -from $ymin -to $ymax -resolution $res
		return 
	}

    toplevel .x

    frame .x.f1 -relief ridge -bd 4
    frame .x.f1.sf0 -relief ridge -bd 2
    frame .x.f1.sf1 -relief ridge -bd 2
    frame .x.f1.sf2 -relief ridge -bd 2
    frame .x.f1.sf3 -relief ridge -bd 2
    frame .x.f1.sf4 -relief ridge -bd 2

    label .x.f1.sf0.l1 -text "X- Range Setting"
    pack .x.f1.sf0.l1 -fill both -expand 1
    set lab "X-Minimum value"
    scale .x.f1.sf1.sc1 -from $xmin -to $xmax -variable x1 -length 200 -orient horizontal \
    -label "$lab" -showvalue true -bg #aabbac -digits 3 -resolution 1  -command { .x.f1.sf1.sc2 configure -from }
    bind .x.f1.sf1.sc1  <ButtonRelease-1> { replot 0}
    set lab "X-Maximum value"
    scale .x.f1.sf1.sc2 -from $xmin -to $xmax -variable x2 -length 200 -orient horizontal \
    -label "$lab" -showvalue true -bg #aabbac -digits 3 -resolution 1 -command { .x.f1.sf1.sc1 configure -to }
    bind .x.f1.sf1.sc2 <ButtonRelease-1> { replot 0}
    pack .x.f1.sf1.sc1 .x.f1.sf1.sc2 -side left -fill both -expand 1

    label .x.f1.sf3.l1 -text "Y- Range Setting"
	button .x.f1.sf3.b1 -text "Update Y-MAX to ->" -command {.x.f1.sf4.sc1 config -to $newyrange;.x.f1.sf4.sc2 config -to $newyrange}
	entry .x.f1.sf3.e1 -textvariable newyrange  -width 10 -bg "#ffdddd"
    pack .x.f1.sf3.l1 .x.f1.sf3.b1 .x.f1.sf3.e1 -side left -fill both -expand 1

    set lab "Y-Minimum value"
    scale .x.f1.sf4.sc1 -from $ymin -to $ymax  -variable y1 -length 200 -orient horizontal \
    -label "$lab" -showvalue true -bg #aabbac -digits 3 -resolution $res  -command { .x.f1.sf4.sc2 configure -from }
    bind .x.f1.sf4.sc1  <ButtonRelease-1> { replot 0}
	bind .x.f1.sf3.e1 <Return> {.x.f1.sf4.sc1 config -to $newyrange;.x.f1.sf4.sc2 config -to $newyrange}
    set lab "Y-Maximum value"
    scale .x.f1.sf4.sc2 -from $ymin -to $ymax -variable y2 -length 200 -orient horizontal \
    -label "$lab" -showvalue true -bg #aabbac -digits 3 -resolution $res -command { .x.f1.sf4.sc1 configure -to }
    bind .x.f1.sf4.sc2 <ButtonRelease-1> { replot 0}
    pack .x.f1.sf4.sc1 .x.f1.sf4.sc2 -side left -fill both -expand 1

    button .x.f1.sf2.b1 -text "Reset X-range" -bd 3 -activeforeground blue -cursor hand2 -command {
		set x1 $xmin; set x2 $xmax; replot 0 
	}
    button .x.f1.sf2.b2 -text "Reset Y-range" -bd 3 -activeforeground blue -cursor hand2 -command {
		set y1 $ymin; set y2 $ymax; replot 0 
	}
    button .x.f1.sf2.b3 -text "Quit" -bd 3 -command {set isrange 0;destroy .x } -activeforeground blue -cursor hand2
    pack .x.f1.sf2.b1 .x.f1.sf2.b2 .x.f1.sf2.b3 -side left -fill both -expand 1

    pack .x.f1.sf0 .x.f1.sf1 .x.f1.sf3 .x.f1.sf4 .x.f1.sf2 -side top -fill both -expand 1
    pack .x.f1 -fill both -expand 1
    wm title .x "Set X-Range"
}

proc replot { term_id } {
	global smpu smpl gnuinp plot_cmd format ft1 ft2 x1 x2 first_plot y1 y2 stopped
	global grid key_val orient gscale op_to print_file print_cmd title1 title2 sb isref
	global ys phson

	set active [ up_count ]
	if { $active == 0 } { 
		set msg "No antennas selected!"
		tk_messageBox  -default ok -message $msg -parent . -title "Error" -type ok
		.f4.cont.start configure -text "  PLAY   |> "
		.f3.print configure -state normal
		.f3.file configure -state normal
		set stopped 1
		return 
	}

	if { $grid == 1 } {
		puts $gnuinp "set grid"
	} elseif { $grid == 0 } {
		puts $gnuinp "set nogrid"
	}

	if { $key_val == 1 } {
		puts $gnuinp "set key"
	} elseif { $key_val == 2 } {
		puts $gnuinp "set nokey"
	}

	if { $term_id == 1 } {
		set title "$title1 $title2"
	} else {
		set title "$title1 \\n $title2"
	}

	puts $gnuinp "set title \"$title\""

	set first_plot 0
	set plot_cmd "plot \"one.band\" "
	set id 1
    while {$id < 31} {
        if { $smpu($id) == 1 } {
            if { $format == 1 } {
                get_cmd 130 $id $ft1 
            } elseif { $format == 2 } {
                get_cmd 130 $id $ft2
            } elseif { $format == 0 } {
                get_cmd 130 $id $ft1
                get_cmd 130 $id $ft2
            }
        }

        if {$smpl($id) == 1} {
            if { $format == 1 } {
                get_cmd 175 $id $ft1
            } elseif { $format == 2 } {
                get_cmd 175 $id $ft2
            } elseif { $format == 0 } {
                get_cmd 175 $id $ft1
                get_cmd 175 $id $ft2
            }
        }
        incr id
    }

	puts $gnuinp "set xrange \[$x1:$x2\]"
	puts $gnuinp "set yrange \[$y1:$y2\]"

	if { $term_id == 1 } {
		puts $gnuinp "set terminal postscript $orient $gscale \"Times-Roman\" 9"
		if { $op_to == 1 } {
			puts $gnuinp "set output \"|$print_cmd\""
		} else {
			puts $gnuinp "set output \"$print_file\""
		}
		destroy .p
	}

    if { $isref == 0 } {
		puts $gnuinp "set $ys y"
    } else {
		if { $phson == 1 } {
			puts $gnuinp "set nologscale y"
		} else {
			puts $gnuinp "set $ys y"
			puts stdout "LOGSCALE=$ys"
		}
    }
	
	puts $gnuinp $plot_cmd
	after 10
	flush $gnuinp
	puts $gnuinp "set terminal X11"
}

proc print_post {} {
    global op_to print_cmd print_file orient gscale sb

    set id 1
    while {1} {
        set print_file band$id.ps
        if { [file exists $print_file ] == 1 } {
            incr id
        } else { break }
    }

    toplevel .p

    frame .p.f1 -relief raise -bd 4
    frame .p.f1.sf1 -relief ridge -bd 0
    frame .p.f1.sf2 -relief ridge -bd 0
    frame .p.f1.sf3 -relief ridge -bd 0
    frame .p.f1.sf4 -relief ridge -bd 0
    frame .p.f1.sf5 -relief ridge -bd 0

    label .p.f1.sf1.l1 -text "Print To :"  -width 25
    radiobutton .p.f1.sf1.r1 -text "Printer" -variable op_to -value 1\
-activeforeground blue -cursor hand2
    radiobutton .p.f1.sf1.r2 -text "File" -variable op_to -value 2\
-activeforeground blue -cursor hand2

    pack .p.f1.sf1.l1 .p.f1.sf1.r2 .p.f1.sf1.r1 -side left -fill both -expand 1

    label .p.f1.sf2.l2 -text "Print Command :" -width 25
    entry .p.f1.sf2.e1 -textvariable print_cmd -state disabled -bg #ffdddd

    pack .p.f1.sf2.l2 .p.f1.sf2.e1 -side left -fill both -expand 1 -pady 3

    label .p.f1.sf3.l1 -text "Print File :" -width 25
    entry .p.f1.sf3.e1 -textvariable print_file -bg #ffdddd

    pack .p.f1.sf3.l1 .p.f1.sf3.e1 -side left -fill both -expand 1 -pady 3

    label .p.f1.sf4.l1 -text "Orientation :"  -width 25
    radiobutton .p.f1.sf4.r1 -text "Landscape" -variable orient -value landscape\
-activeforeground blue -cursor hand2
    radiobutton .p.f1.sf4.r2 -text "Portrait" -variable orient -value portrait\
-activeforeground blue -cursor hand2

    pack .p.f1.sf4.l1 .p.f1.sf4.r1 .p.f1.sf4.r2 -side left -fill both -expand 1

    label .p.f1.sf5.l1 -text "Print Copy :"  -width 25
    radiobutton .p.f1.sf5.r1 -text "Grayscale" -variable gscale -value monochrome\
-activeforeground blue -cursor hand2
    radiobutton .p.f1.sf5.r2 -text "Color" -variable gscale -value color\
-activeforeground blue -cursor hand2

    pack .p.f1.sf5.l1 .p.f1.sf5.r1 .p.f1.sf5.r2 -side left -fill both -expand 1

    pack .p.f1.sf1 .p.f1.sf2 .p.f1.sf3 .p.f1.sf4 .p.f1.sf5 -side top -fill y -expand 1 -pady 3

    frame .p.f2 -relief raise -bd 5
    button .p.f2.b1 -text "OK" -command {replot 1} -activeforeground blue -cursor hand2
    button .p.f2.b2 -text "Help" -command {help} -activeforeground blue -cursor hand2
    button .p.f2.b3 -text "Cancel" -command {destroy .p; return} -activeforeground blue -cursor hand2

    pack .p.f2.b1 .p.f2.b2 .p.f2.b3 -side left -padx 7 -ipadx 5 -pady 3 -fill both -expand 1
    pack .p.f1 .p.f2 -side top -fill both -expand 1

    wm title .p "Printing Menus"
   
    bind .p.f1.sf1.r1 <1> {
        .p.f1.sf3.e1 configure -state disabled
        .p.f1.sf2.e1 configure -state normal
    }

    bind .p.f1.sf1.r2 <1> {
        .p.f1.sf2.e1 configure -state disabled
        .p.f1.sf3.e1 configure -state normal
    }
}

bind .f2.format.rad1 <1> {
	if { $oneformat == 0 } {
		set format 1
	} else {
		set format 1
	}
	update_scale 
}

bind .f2.format.rad2 <1> {
	if { $oneformat == 0 } {
		set format 2
	} else {
		set format 1
	}
	update_scale 
}

bind .f2.format.rad3 <1> {
	if { $oneformat == 0 } {
		set format 0
	} else {
		set format 1
	}
	update_scale 
}

proc update_scale {} {
	global x1 x2 y1 y2 xmin xmax ymin ymax isrange res gnuinp
	global oneformat data_format isref format

	if { $isref == 0 } {
		set y1 10
		set y2 5000
		set ymin 1
		set ymax 50000
		set res 1
	} elseif { $oneformat == 1 } {
		if { $data_format == 1 } {
			set y1 0.0
			set y2 0.25
			set ymin 0.0
			set ymax 1.00
			set res .005
		} elseif { $data_format == 2 } {
			set y1 -200
			set y2  200
			set ymin -200
			set ymax 200
			set res 1
		}
	} elseif { $oneformat == 0 } {
		if { $format == 1 } {
			set y1 0.0
			set y2 0.25
			set ymin 0.0
			set ymax 1.00
			set res .005
		} elseif { $format == 2 || $format == 0} {
			set y1 -200
			set y2  200
			set ymin -200
			set ymax 200
			set res 1
		}
	}

	puts $gnuinp "set xrange \[$x1:$x2\]"
	puts $gnuinp "set yrange \[$y1:$y2\]"

	if { $isrange == 1 } {
	   	.x.f1.sf1.sc1 config -from $xmin -to $xmax
		.x.f1.sf1.sc2 config -from $xmin -to $xmax
	   	.x.f1.sf4.sc1 config -from $ymin -to $ymax -resolution $res
		.x.f1.sf4.sc2 config -from $ymin -to $ymax -resolution $res
	}
#	set_range
}
